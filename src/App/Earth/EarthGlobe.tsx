/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: BamPistache (https://sketchfab.com/karinkreeft8)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/earth-0caafb7e837047a688a3e504c0ea74af
title: Earth
*/

import { useGLTF } from "@react-three/drei";
import { useEffect, useMemo, useRef } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";
import { useStore } from "../store/store";

// @ts-ignore
import modelPath from "../../assets/earth/scene.glb";
import { MathUtils } from "three";
import { TessellateModifier } from "three-stdlib";

export const EarthGlobe = (props: any) => {
  const gltf = useGLTF(modelPath);
  const { nodes } = gltf;

  const gradientMap = useMemo(() => {
    const canvas = document.createElement("canvas");
    canvas.width = 18;
    canvas.height = 1;

    const context = canvas.getContext("2d")!;
    context.fillStyle = "#888";
    context.fillRect(0, 0, 100, 1);

    context.fillStyle = "#444";
    context.fillRect(0, 0, 10, 1);

    context.fillStyle = "#000";
    context.fillRect(0, 0, 8, 1);

    const gradientMap = new THREE.Texture(canvas);
    gradientMap.minFilter = THREE.NearestFilter;
    gradientMap.magFilter = THREE.NearestFilter;
    gradientMap.needsUpdate = true;

    return gradientMap;
  }, []);

  const n = 64;
  const gradientMapNTone = useMemo(() => {
    const canvas = document.createElement("canvas");
    canvas.width = n;
    canvas.height = 1;

    // canvas.style.width = "100px";
    // canvas.style.height = "100px";
    // canvas.style.imageRendering = "pixelated";
    // canvas.style.border = "solid 1px orange";
    // document.body.appendChild(canvas);

    const context = canvas.getContext("2d")!;

    for (let i = n; i--; ) {
      const k = i / (n - 1);
      const a = (0.45 < k && k < 0.8 ? 0.72 : k) * 255;
      context.fillStyle = `rgb(${a},${a},${a})`;
      context.fillRect(i, 0, 1, 1);
    }

    const gradientMap = new THREE.Texture(canvas);
    gradientMap.minFilter = THREE.NearestFilter;
    gradientMap.magFilter = THREE.NearestFilter;
    gradientMap.needsUpdate = true;

    return gradientMap;
  }, [n]);

  const landGeometry = useMemo(() => {
    const geo: THREE.BufferGeometry = (nodes.earth4_lambert1_0 as any).geometry.clone();

    const position = geo.getAttribute("position");
    geo.deleteAttribute("uv");

    const ls: number[] = [];

    for (let i = 0; i < position.count; i++) {
      const p = new THREE.Vector3(
        position.getX(i),
        position.getY(i),
        position.getZ(i)
      );

      const l = p.length();
      if (l > 8.5) ls.push(l);
    }

    const min = Math.min(...ls);
    const max = Math.max(...ls);

    for (let i = 0; i < position.count; i++) {
      const p = new THREE.Vector3(
        position.getX(i),
        position.getY(i),
        position.getZ(i)
      );

      const l = p.length();

      const u = MathUtils.clamp((l - min) / (max - min), 0, 1);

      p.normalize().multiplyScalar(1 + Math.pow(u, 1 / 1.5) * 0.06);

      position.setXYZ(i, p.x, p.y, p.z);
    }

    geo.computeVertexNormals();

    const tm = new TessellateModifier(0.01, 2);
    const geo2 = tm.modify(geo);
    return geo2;
  }, [nodes.earth4_lambert1_0]);

  const outLineRef = useRef<THREE.Object3D>();
  const { camera } = useThree();
  useFrame(() => {
    const d = camera.position.length();
    outLineRef.current?.scale.setScalar(1 + d * 0.01);
  });

  useEffect(() => useStore.getState().onEarthReady(), []);

  return (
    <group {...props} dispose={null}>
      <mesh>
        <sphereBufferGeometry args={[1, 32, 32]} />
        {/* <meshToonMaterial
          color={"#ff97f6"}
          gradientMap={gradientMap}
          opacity={0.4}
          transparent
        /> */}
        <meshToonMaterial color={"#97ceff"} gradientMap={gradientMap} />
      </mesh>

      <mesh ref={outLineRef}>
        <sphereBufferGeometry args={[1, 32, 32]} />
        <meshBasicMaterial color={"#769550"} side={THREE.BackSide} />
      </mesh>

      <mesh geometry={landGeometry}>
        <meshToonMaterial
          color={"#ceff97"}
          gradientMap={gradientMapNTone}
          side={THREE.FrontSide}
          // wireframe
          // opacity={0.4}
          // transparent
        />
      </mesh>
    </group>
  );
};
