/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: BamPistache (https://sketchfab.com/karinkreeft8)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/earth-0caafb7e837047a688a3e504c0ea74af
title: Earth
*/

import { useGLTF } from "@react-three/drei";
import { useEffect, useMemo, useRef } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";
import { useStore } from "../store/store";

// @ts-ignore
import modelPath from "../../assets/earth/scene.glb";

const createOceanGradientMap = () => {
  const canvas = document.createElement("canvas");
  canvas.width = 18;
  canvas.height = 1;

  const context = canvas.getContext("2d")!;
  context.fillStyle = "#888";
  context.fillRect(0, 0, 100, 1);

  context.fillStyle = "#444";
  context.fillRect(0, 0, 10, 1);

  context.fillStyle = "#000";
  context.fillRect(0, 0, 8, 1);

  const gradientMap = new THREE.Texture(canvas);
  gradientMap.minFilter = THREE.NearestFilter;
  gradientMap.magFilter = THREE.NearestFilter;
  gradientMap.needsUpdate = true;

  return gradientMap;
};
const createLandGradientMap = () => {
  const n = 6;

  const canvas = document.createElement("canvas");
  canvas.width = n;
  canvas.height = 1;

  // canvas.style.width = "100px";
  // canvas.style.height = "100px";
  // canvas.style.imageRendering = "pixelated";
  // canvas.style.border = "solid 1px orange";
  // document.body.appendChild(canvas);

  const context = canvas.getContext("2d")!;

  for (let i = n; i--; ) {
    const k = i / (n - 1);
    const a = (0.45 < k && k < 0.8 ? 0.72 : k) * 255;
    context.fillStyle = `rgb(${a},${a},${a})`;
    context.fillRect(i, 0, 1, 1);
  }

  const gradientMap = new THREE.Texture(canvas);
  gradientMap.minFilter = THREE.NearestFilter;
  gradientMap.magFilter = THREE.NearestFilter;
  gradientMap.needsUpdate = true;

  return gradientMap;
};

export const EarthGlobe = (props: any) => {
  const gltf = useGLTF(modelPath);
  const { geometry } = (gltf as any).nodes.mesh_0;

  const gradientMapOcean = useMemo(createOceanGradientMap, []);
  const gradientMapLand = useMemo(createLandGradientMap, []);

  const outLineRef = useRef<THREE.Object3D>();
  const { camera } = useThree();
  useFrame(() => {
    const d = camera.position.length();
    outLineRef.current?.scale.setScalar(1 + d * 0.01);
  });

  useEffect(() => useStore.getState().onEarthReady(), []);

  return (
    <group {...props} dispose={null}>
      <mesh>
        <sphereBufferGeometry args={[1, 32, 32]} />
        <meshToonMaterial color={"#97ceff"} gradientMap={gradientMapOcean} />
      </mesh>

      <mesh ref={outLineRef}>
        <sphereBufferGeometry args={[1, 32, 32]} />
        <meshBasicMaterial color={"#769550"} side={THREE.BackSide} />
      </mesh>

      {!false && (
        <mesh geometry={geometry}>
          <meshToonMaterial color={"#ceff97"} gradientMap={gradientMapLand} />
        </mesh>
      )}
    </group>
  );
};
