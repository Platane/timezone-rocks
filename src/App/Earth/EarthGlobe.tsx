/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: BamPistache (https://sketchfab.com/karinkreeft8)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/earth-0caafb7e837047a688a3e504c0ea74af
title: Earth
*/

import { useGLTF } from "@react-three/drei";
import { useEffect, useMemo, useRef } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";
import { useStore } from "../store/store";

// @ts-ignore
import modelPath from "../../assets/earth/scene.glb";
import { MathUtils } from "three";

export const transform = (geo: THREE.BufferGeometry) => {
  // geo = new THREE.SphereBufferGeometry(1, 4, 2);

  geo.deleteAttribute("uv");

  // resize
  if (!0) {
    const ls: number[] = [];
    const position = geo.getAttribute("position")!;

    for (let i = 0; i < position.count; i++) {
      const p = new THREE.Vector3(
        position.getX(i),
        position.getY(i),
        position.getZ(i)
      );

      const l = p.length();
      if (l > 8.5) ls.push(l);
    }

    const min = Math.min(...ls);
    const max = Math.max(...ls);

    console.log(min, max);

    for (let i = 0; i < position.count; i++) {
      const p = new THREE.Vector3(
        position.getX(i),
        position.getY(i),
        position.getZ(i)
      );

      const l = p.length();

      const u = MathUtils.clamp((l - min) / (max - min), 0, 1);

      p.normalize().multiplyScalar(1 + Math.pow(u, 1 / 1.5) * 0.06);

      position.setXYZ(i, p.x, p.y, p.z);
    }
  }

  //

  // const tessellateModifier = new TessellateModifier(0.18, 2);
  // return tessellateModifier.modify(geo);

  // {
  //   geo.toNonIndexed();
  //   const position = geo.getAttribute("position")!;
  //   const normal = geo.getAttribute("normal")!;
  //   const faces = [];
  //   for (let i = 0; i < position.count; i += 3) {
  //     const [a, b, c] = [0, 1, 2].map((j) =>
  //       new THREE.Vector3().fromBufferAttribute(position, i + j)
  //     );

  //     const m = new THREE.Vector3()
  //       .addScaledVector(a, 1 / 3)
  //       .addScaledVector(b, 1 / 3)
  //       .addScaledVector(c, 1 / 3);
  //   }

  // }

  geo = geo.toNonIndexed();
  if (!0) {
    const position = geo.getAttribute("position")!;
    const normal = geo.getAttribute("normal")!;
    const newNormals: THREE.Vector3[] = [];

    {
      const ps: THREE.Vector3[] = [];
      for (let j = 0; j < position.count; j += 1)
        ps.push(new THREE.Vector3().fromBufferAttribute(position, j));
      console.log(ps);
    }

    const getFaces = (p: THREE.Vector3) => {
      const f = [];

      for (let j = 0; j < position.count; j += 1) {
        const p0 = new THREE.Vector3().fromBufferAttribute(position, j);
        if (p.distanceTo(p0) < 0.00001) {
          const i0 = Math.floor(j / 3) * 3;
          f.push([i0 + 0, i0 + 1, i0 + 2]);
        }
      }

      return f;
    };

    for (let i = 0; i < position.count; i += 1) {
      const p = new THREE.Vector3().fromBufferAttribute(position, i);
      const n = new THREE.Vector3();

      let totalArea = 0;

      getFaces(p).forEach((indexes) => {
        // mean normal of the face
        const facePreviousN = new THREE.Vector3();
        for (const i of indexes) {
          const n0 = new THREE.Vector3().fromBufferAttribute(normal, i);
          facePreviousN.addScaledVector(n0, 1 / 3);
        }
        facePreviousN.normalize();

        const [a, b, c] = indexes.map((i) =>
          new THREE.Vector3().fromBufferAttribute(position, i)
        );

        const faceN = new THREE.Vector3()
          .subVectors(b, a)
          .cross(new THREE.Vector3().subVectors(c, a))
          .normalize();

        if (faceN.dot(facePreviousN) < 0) faceN.negate();

        const u = new THREE.Vector3();
        const v = new THREE.Vector3();

        u.subVectors(a, p);
        v.subVectors(b, p);

        if (u.length() < 0.00001) u.subVectors(c, p);
        if (v.length() < 0.00001) v.subVectors(c, p);

        u.normalize();
        v.normalize();

        const area = new THREE.Vector3().crossVectors(u, v).length();

        totalArea += area;

        n.addScaledVector(faceN, area);
      });

      n.normalize();

      const previousN = new THREE.Vector3().fromBufferAttribute(normal, i);

      const k = MathUtils.clamp(totalArea / 5, 0.5, 1);
      console.log(totalArea, k);

      newNormals.push(new THREE.Vector3().lerpVectors(previousN, n, k));
    }

    for (let i = 0; i < newNormals.length; i++)
      normal.setXYZ(i, newNormals[i].x, newNormals[i].y, newNormals[i].z);
    // normal.setXYZ(i, 0, 0, 1);

    normal.needsUpdate = true;

    // geo.computeVertexNormals();
  }

  {
    const normal = geo.getAttribute("normal")!;
    const ps: THREE.Vector3[] = [];
    for (let j = 0; j < normal.count; j += 1)
      ps.push(new THREE.Vector3().fromBufferAttribute(normal, j));
    console.log(ps.slice(0, 20));
  }

  return geo;
};

export const EarthGlobe = (props: any) => {
  const gltf = useGLTF(modelPath);

  const gradientMap = useMemo(() => {
    const canvas = document.createElement("canvas");
    canvas.width = 18;
    canvas.height = 1;

    const context = canvas.getContext("2d")!;
    context.fillStyle = "#888";
    context.fillRect(0, 0, 100, 1);

    context.fillStyle = "#444";
    context.fillRect(0, 0, 10, 1);

    context.fillStyle = "#000";
    context.fillRect(0, 0, 8, 1);

    const gradientMap = new THREE.Texture(canvas);
    gradientMap.minFilter = THREE.NearestFilter;
    gradientMap.magFilter = THREE.NearestFilter;
    gradientMap.needsUpdate = true;

    return gradientMap;
  }, []);

  const n = 64;
  const gradientMapNTone = useMemo(() => {
    const canvas = document.createElement("canvas");
    canvas.width = n;
    canvas.height = 1;

    // canvas.style.width = "100px";
    // canvas.style.height = "100px";
    // canvas.style.imageRendering = "pixelated";
    // canvas.style.border = "solid 1px orange";
    // document.body.appendChild(canvas);

    const context = canvas.getContext("2d")!;

    for (let i = n; i--; ) {
      const k = i / (n - 1);
      const a = (0.45 < k && k < 0.8 ? 0.72 : k) * 255;
      context.fillStyle = `rgb(${a},${a},${a})`;
      context.fillRect(i, 0, 1, 1);
    }

    const gradientMap = new THREE.Texture(canvas);
    gradientMap.minFilter = THREE.NearestFilter;
    gradientMap.magFilter = THREE.NearestFilter;
    gradientMap.needsUpdate = true;

    return gradientMap;
  }, [n]);

  const landGeometry = useMemo(
    () =>
      transform(
        // @ts-ignore
        gltf.nodes.earth4_lambert1_0.geometry.clone()
      ),
    [gltf]
  );

  const outLineRef = useRef<THREE.Object3D>();
  const { camera } = useThree();
  useFrame(() => {
    const d = camera.position.length();
    outLineRef.current?.scale.setScalar(1 + d * 0.01);
  });

  useEffect(() => useStore.getState().onEarthReady(), []);

  return (
    <group {...props} dispose={null}>
      {false && (
        <mesh>
          <sphereBufferGeometry args={[1, 32, 32]} />
          {/* <meshToonMaterial
          color={"#ff97f6"}
          gradientMap={gradientMap}
          opacity={0.4}
          transparent
        /> */}
          <meshToonMaterial color={"#97ceff"} gradientMap={gradientMap} />
        </mesh>
      )}

      {false && (
        <mesh ref={outLineRef}>
          <sphereBufferGeometry args={[1, 32, 32]} />
          <meshBasicMaterial color={"#769550"} side={THREE.BackSide} />
        </mesh>
      )}

      <mesh geometry={landGeometry}>
        <meshPhysicalMaterial
          color={"#ceff97"}
          roughness={0}
          side={THREE.FrontSide}
          // wireframe
          // opacity={0.4}
          // transparent
        />
      </mesh>
    </group>
  );
};
