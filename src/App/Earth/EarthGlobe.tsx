/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: BamPistache (https://sketchfab.com/karinkreeft8)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/earth-0caafb7e837047a688a3e504c0ea74af
title: Earth
*/

import { useGLTF } from "@react-three/drei";
import { useEffect, useMemo, useRef } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";
import { useStore } from "../store/store";

// @ts-ignore
import modelPath from "../../assets/earth/scene.glb";
import { MathUtils } from "three";
import { TessellateModifier } from "three-stdlib";

export const EarthGlobe = (props: any) => {
  const gltf = useGLTF(modelPath);
  const { nodes } = gltf;

  const gradientMap = useMemo(() => {
    const canvas = document.createElement("canvas");
    canvas.width = 18;
    canvas.height = 1;

    const context = canvas.getContext("2d")!;
    context.fillStyle = "#888";
    context.fillRect(0, 0, 100, 1);

    context.fillStyle = "#444";
    context.fillRect(0, 0, 10, 1);

    context.fillStyle = "#000";
    context.fillRect(0, 0, 8, 1);

    const gradientMap = new THREE.Texture(canvas);
    gradientMap.minFilter = THREE.NearestFilter;
    gradientMap.magFilter = THREE.NearestFilter;
    gradientMap.needsUpdate = true;

    return gradientMap;
  }, []);

  const n = 64;
  const gradientMapNTone = useMemo(() => {
    const canvas = document.createElement("canvas");
    canvas.width = n;
    canvas.height = 1;

    // canvas.style.width = "100px";
    // canvas.style.height = "100px";
    // canvas.style.imageRendering = "pixelated";
    // canvas.style.border = "solid 1px orange";
    // document.body.appendChild(canvas);

    const context = canvas.getContext("2d")!;

    for (let i = n; i--; ) {
      const k = i / (n - 1);
      const a = (0.45 < k && k < 0.8 ? 0.72 : k) * 255;
      context.fillStyle = `rgb(${a},${a},${a})`;
      context.fillRect(i, 0, 1, 1);
    }

    const gradientMap = new THREE.Texture(canvas);
    gradientMap.minFilter = THREE.NearestFilter;
    gradientMap.magFilter = THREE.NearestFilter;
    gradientMap.needsUpdate = true;

    return gradientMap;
  }, [n]);

  const landGeometry = useMemo(() => {
    // const geo: THREE.BufferGeometry = (nodes.earth4_lambert1_0 as any).geometry.clone();

    const geo = new THREE.SphereBufferGeometry(1, 4, 2);

    const position = geo.getAttribute("position");
    geo.deleteAttribute("uv");

    const ls: number[] = [];

    for (let i = 0; i < position.count; i++) {
      const p = new THREE.Vector3(
        position.getX(i),
        position.getY(i),
        position.getZ(i)
      );

      const l = p.length();
      if (l > 8.5) ls.push(l);
    }

    const min = Math.min(...ls);
    const max = Math.max(...ls);

    // for (let i = 0; i < position.count; i++) {
    //   const p = new THREE.Vector3(
    //     position.getX(i),
    //     position.getY(i),
    //     position.getZ(i)
    //   );

    //   const l = p.length();

    //   const u = MathUtils.clamp((l - min) / (max - min), 0, 1);

    //   p.normalize().multiplyScalar(1 + Math.pow(u, 1 / 1.5) * 0.06);

    //   position.setXYZ(i, p.x, p.y, p.z);
    // }

    // geo.computeVertexNormals();

    {
      geo.toNonIndexed();
      const position = geo.getAttribute("position")!;
      const normal = geo.getAttribute("normal")!;
      const faces = [];
      for (let i = 0; i < position.count; i += 3) {
        const ia = index.getX(i + 0);
        const ib = index.getX(i + 1);
        const ic = index.getX(i + 2);

        const a = new THREE.Vector3(
          position.getX(ia),
          position.getY(ia),
          position.getZ(ia)
        );
        const b = new THREE.Vector3(
          position.getX(ib),
          position.getY(ib),
          position.getZ(ib)
        );
        const c = new THREE.Vector3(
          position.getX(ic),
          position.getY(ic),
          position.getZ(ic)
        );

        const m = new THREE.Vector3()
          .addScaledVector(a, 1 / 3)
          .addScaledVector(b, 1 / 3)
          .addScaledVector(c, 1 / 3);

          position.
      }

      return geo;
    }
  }, [nodes.earth4_lambert1_0]);

  const outLineRef = useRef<THREE.Object3D>();
  const { camera } = useThree();
  useFrame(() => {
    const d = camera.position.length();
    outLineRef.current?.scale.setScalar(1 + d * 0.01);
  });

  useEffect(() => useStore.getState().onEarthReady(), []);

  return (
    <group {...props} dispose={null}>
      {false && (
        <mesh>
          <sphereBufferGeometry args={[1, 32, 32]} />
          {/* <meshToonMaterial
          color={"#ff97f6"}
          gradientMap={gradientMap}
          opacity={0.4}
          transparent
        /> */}
          <meshToonMaterial color={"#97ceff"} gradientMap={gradientMap} />
        </mesh>
      )}

      {false && (
        <mesh ref={outLineRef}>
          <sphereBufferGeometry args={[1, 32, 32]} />
          <meshBasicMaterial color={"#769550"} side={THREE.BackSide} />
        </mesh>
      )}

      <mesh geometry={landGeometry}>
        <meshToonMaterial
          color={"#ceff97"}
          gradientMap={gradientMapNTone}
          side={THREE.FrontSide}
          wireframe
          // opacity={0.4}
          // transparent
        />
      </mesh>
    </group>
  );
};
